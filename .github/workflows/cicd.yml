name: 'Homelab Infrastructure Pipeline'

on:
  push:
    branches: [ main ]
    paths:
      - 'infrastructure-as-code/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'infrastructure-as-code/**'

env:
  TF_VERSION: "1.12.2"
  NODE_VERSION: "20"
  WORKING_DIR: "./infrastructure-as-code"

jobs:
  validate:
    name: 'Validate Terraform'
    runs-on: ubuntu-latest
    steps:
      - name: 'Checkout'
        uses: actions/checkout@v4

      - name: 'Setup Node.js'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: 'Setup Terraform'
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      - name: 'Terraform Format Check'
        run: terraform fmt -check -recursive
        working-directory: ${{ env.WORKING_DIR }}/introduction-to-terraform

      - name: 'Terraform Init'
        run: terraform init -input=false
        working-directory: ${{ env.WORKING_DIR }}/introduction-to-terraform

      - name: 'Terraform Validate'
        run: terraform validate
        working-directory: ${{ env.WORKING_DIR }}/introduction-to-terraform

  plan:
    name: 'Terraform Plan'
    needs: validate
    runs-on: [self-hosted, homelab]
    permissions:
      contents: read
      pull-requests: write
    if: github.event_name == 'pull_request'
    
    steps:
      - name: 'Checkout'
        uses: actions/checkout@v4

      - name: 'Setup Node.js'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: 'Setup Terraform'
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      - name: 'Setup SSH Key for Libvirt'
        run: |
          # Create SSH directory
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Add SSH private key (used for both Terraform and Ansible)
          echo "${{ secrets.LIBVIRT_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # Generate public key from private key
          ssh-keygen -y -f ~/.ssh/id_rsa > ~/.ssh/id_rsa.pub
          
          # Create SSH config for libvirt host
          cat > ~/.ssh/config << EOF
          Host 192.168.0.40 libvirt-host
            HostName 192.168.0.40
            Port 42
            User amathis
            IdentityFile ~/.ssh/id_rsa
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            LogLevel ERROR
          
          Host master-* worker-* *.local
            User ubuntu
            IdentityFile ~/.ssh/id_rsa
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            LogLevel ERROR
          EOF
          chmod 600 ~/.ssh/config
          
          # Test SSH connection to libvirt host
          echo "Testing SSH connection to libvirt host..."
          ssh -o ConnectTimeout=10 192.168.0.40 "echo 'SSH connection successful'" || {
            echo "‚ùå SSH connection failed"
            echo "Debug: Testing with verbose output..."
            ssh -vvv 192.168.0.40 "echo 'test'" 2>&1 | tail -20
            exit 1
          }
          
          echo "‚úÖ SSH connection to libvirt host successful"

      - name: 'Verify SSH Key Authorization'
        run: |
          echo "üîç Verifying SSH key is authorized on target host..."
          ssh 192.168.0.40 "cat ~/.ssh/authorized_keys | grep -q '$(ssh-keygen -yf ~/.ssh/id_rsa | cut -d' ' -f2)'" || {
            echo "‚ùå SSH key not found in authorized_keys"
            echo "Your public key:"
            ssh-keygen -yf ~/.ssh/id_rsa
            echo "Authorized keys on target:"
            ssh 192.168.0.40 "cat ~/.ssh/authorized_keys" 2>/dev/null || echo "Cannot read authorized_keys"
            exit 1
          }
          echo "‚úÖ SSH key is properly authorized"

      - name: 'Test Libvirt Access'
        run: |
          echo "üîç Testing libvirt access..."
          ssh 192.168.0.40 "id" || {
            echo "‚ùå Cannot get user info"
            exit 1
          }
          
          ssh 192.168.0.40 "groups" || {
            echo "‚ùå Cannot get group info"
            exit 1
          }
          
          ssh 192.168.0.40 "virsh version" || {
            echo "‚ùå Cannot access libvirt - user may not be in libvirt group"
            echo "User groups:"
            ssh 192.168.0.40 "groups"
            exit 1
          }
          
          echo "‚úÖ Libvirt access confirmed"

      - name: 'Start SSH Agent and Add Key'
        run: |
          # Start SSH agent
          eval $(ssh-agent -s)
          
          # Add SSH key to agent
          ssh-add ~/.ssh/id_rsa
          
          # List loaded keys
          ssh-add -l
          
          # Export SSH_AUTH_SOCK for subsequent steps
          echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> $GITHUB_ENV
          echo "SSH_AGENT_PID=$SSH_AGENT_PID" >> $GITHUB_ENV

      - name: 'Test Terraform Cloud Connectivity'
        run: |
          echo "Testing connection to Terraform Cloud..."
          curl -f https://app.terraform.io/api/v2/ping || {
            echo "‚ùå Cannot reach Terraform Cloud"
            exit 1
          }
          echo "‚úÖ Terraform Cloud is reachable"

      - name: 'Debug Environment'
        run: |
          echo "üîç Environment Debug Information:"
          echo "Node.js version: $(node --version)"
          echo "NPM version: $(npm --version)"
          echo "Terraform version: $(terraform --version)"
          echo "Working directory: $(pwd)"
          echo "SSH Agent: $SSH_AUTH_SOCK"
          echo "SSH keys loaded:"
          ssh-add -l || echo "No keys in agent"
          echo "Directory contents:"
          ls -la ${{ env.WORKING_DIR }}
          echo "SSH config:"
          cat ~/.ssh/config || echo "No SSH config"
          echo "Testing libvirt connection again:"
          ssh 192.168.0.40 "uname -a" || echo "SSH test failed"

      - name: 'Start SSH Agent'
        run: |
          # Start SSH agent
          eval $(ssh-agent -s)
          echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> $GITHUB_ENV
          echo "SSH_AGENT_PID=$SSH_AGENT_PID" >> $GITHUB_ENV

      - name: 'Add SSH Key to Agent'
        run: ssh-add ~/.ssh/id_rsa

      - name: 'Run Make Plan'
        id: plan
        env:
          SSH_AUTH_SOCK: ${{ env.SSH_AUTH_SOCK }}
        run: |
          cd ${{ env.WORKING_DIR }}
          
          # Run the plan
          make plan 2>&1 | tee plan_output.txt
          
          # Capture the exit code
          PLAN_EXIT_CODE=${PIPESTATUS[0]}
          echo "plan_exit_code=$PLAN_EXIT_CODE" >> $GITHUB_OUTPUT
          
          # Capture the output
          echo "plan_output<<EOF" >> $GITHUB_OUTPUT
          cat plan_output.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Exit with the original exit code
          exit $PLAN_EXIT_CODE
        continue-on-error: true

      - name: 'Comment Plan Results'
        uses: actions/github-script@v7
        if: always()
        with:
          script: |
            const planExitCode = '${{ steps.plan.outputs.plan_exit_code }}';
            const planOutput = `${{ steps.plan.outputs.plan_output }}`;
            const status = planExitCode === '0' ? '‚úÖ Success' : '‚ùå Failed';
            
            const output = `
            ## üèóÔ∏è Terraform Plan Results ${status}
            
            **Exit Code**: \`${planExitCode}\`
            
            <details>
            <summary>üìã Plan Output (Click to expand)</summary>
            
            \`\`\`
            ${planOutput}
            \`\`\`
            
            </details>
            
            **Workflow**: \`${{ github.workflow }}\`
            **Action**: \`${{ github.event_name }}\`
            **Commit**: \`${{ github.sha }}\`
            **Runner**: \`self-hosted\`
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })

      - name: 'Cleanup SSH'
        if: always()
        run: |
          # Kill SSH agent
          kill $SSH_AGENT_PID || true
          # Remove SSH key
          rm -f ~/.ssh/id_rsa
          
      - name: 'Fail if Plan Failed'
        if: steps.plan.outputs.plan_exit_code != '0'
        run: |
          echo "‚ùå Terraform plan failed with exit code: ${{ steps.plan.outputs.plan_exit_code }}"
          exit 1

  deploy:
    name: 'Deploy Infrastructure'
    needs: validate
    runs-on: [self-hosted, homelab]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - name: 'Checkout'
        uses: actions/checkout@v4

      - name: 'Setup Node.js'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: 'Setup Terraform'
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      - name: 'Setup Ansible'
        run: |
          sudo apt-get update
          sudo apt-get install -y ansible python3-kubernetes

      - name: 'Setup SSH Key for Libvirt'
        run: |
          # Create SSH directory
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Add SSH private key (used for both Terraform and Ansible)
          echo "${{ secrets.LIBVIRT_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # Generate public key from private key
          ssh-keygen -y -f ~/.ssh/id_rsa > ~/.ssh/id_rsa.pub
          
          # Create SSH config for libvirt host
          cat > ~/.ssh/config << EOF
          Host 192.168.0.40 libvirt-host
            HostName 192.168.0.40
            Port 42
            User amathis
            IdentityFile ~/.ssh/id_rsa
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            LogLevel ERROR
          
          Host master-* worker-* *.local
            User ubuntu
            IdentityFile ~/.ssh/id_rsa
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            LogLevel ERROR
          EOF
          chmod 600 ~/.ssh/config
          
          # Test SSH connection to libvirt host
          echo "Testing SSH connection to libvirt host..."
          ssh -o ConnectTimeout=10 192.168.0.40 "echo 'SSH connection successful'" || {
            echo "‚ùå SSH connection failed"
            echo "Debug: Testing with verbose output..."
            ssh -vvv 192.168.0.40 "echo 'test'" 2>&1 | tail -20
            exit 1
          }
          
          echo "‚úÖ SSH connection to libvirt host successful"

      - name: 'Verify SSH Key Authorization'
        run: |
          echo "üîç Verifying SSH key is authorized on target host..."
          ssh 192.168.0.40 "cat ~/.ssh/authorized_keys | grep -q '$(ssh-keygen -yf ~/.ssh/id_rsa | cut -d' ' -f2)'" || {
            echo "‚ùå SSH key not found in authorized_keys"
            echo "Your public key:"
            ssh-keygen -yf ~/.ssh/id_rsa
            echo "Authorized keys on target:"
            ssh 192.168.0.40 "cat ~/.ssh/authorized_keys" 2>/dev/null || echo "Cannot read authorized_keys"
            exit 1
          }
          echo "‚úÖ SSH key is properly authorized"

      - name: 'Test Libvirt Access'
        run: |
          echo "üîç Testing libvirt access..."
          ssh 192.168.0.40 "id" || {
            echo "‚ùå Cannot get user info"
            exit 1
          }
          
          ssh 192.168.0.40 "groups" || {
            echo "‚ùå Cannot get group info"
            exit 1
          }
          
          ssh 192.168.0.40 "virsh version" || {
            echo "‚ùå Cannot access libvirt - user may not be in libvirt group"
            echo "User groups:"
            ssh 192.168.0.40 "groups"
            exit 1
          }
          
          echo "‚úÖ Libvirt access confirmed"

      - name: 'Deploy Infrastructure'
        id: deploy
        env:
          SSH_AUTH_SOCK: ${{ env.SSH_AUTH_SOCK }}
        run: |
          cd ${{ env.WORKING_DIR }}
          echo "üöÄ Starting infrastructure deployment..."
          make deploy 2>&1 | tee deploy_output.txt
          
          # Capture the exit code
          DEPLOY_EXIT_CODE=${PIPESTATUS[0]}
          echo "deploy_exit_code=$DEPLOY_EXIT_CODE" >> $GITHUB_OUTPUT
          
          # Capture the output
          echo "deploy_output<<EOF" >> $GITHUB_OUTPUT
          cat deploy_output.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Exit with the original exit code
          exit $DEPLOY_EXIT_CODE

      - name: 'Create Deployment Summary'
        if: steps.deploy.outputs.deploy_exit_code == '0'
        run: |
          echo "# üéâ Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Infrastructure Status" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          cd ${{ env.WORKING_DIR }}/introduction-to-terraform
          terraform output 2>/dev/null || echo "No outputs available"
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

      - name: 'Cleanup SSH'
        if: always()
        run: |
          kill $SSH_AGENT_PID || true
          rm -f ~/.ssh/id_rsa

      - name: 'Upload Deployment Logs'
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-logs
          path: ${{ env.WORKING_DIR }}/deploy_output.txt
          retention-days: 30

  cleanup:
    name: 'Cleanup on Failure'
    needs: [deploy]
    runs-on: [self-hosted, homelab]
    if: failure() && github.ref == 'refs/heads/main'
    
    steps:
      - name: 'Checkout'
        uses: actions/checkout@v4

      - name: 'Setup Node.js'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: 'Setup Terraform'
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      - name: 'Setup SSH Key for Libvirt'
        run: |
          # Create SSH directory
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Add SSH private key (used for both Terraform and Ansible)
          echo "${{ secrets.LIBVIRT_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # Generate public key from private key
          ssh-keygen -y -f ~/.ssh/id_rsa > ~/.ssh/id_rsa.pub
          
          # Create SSH config for libvirt host
          cat > ~/.ssh/config << EOF
          Host 192.168.0.40 libvirt-host
            HostName 192.168.0.40
            Port 42
            User amathis
            IdentityFile ~/.ssh/id_rsa
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            LogLevel ERROR
          
          Host master-* worker-* *.local
            User ubuntu
            IdentityFile ~/.ssh/id_rsa
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            LogLevel ERROR
          EOF
          chmod 600 ~/.ssh/config
           
          # Test SSH connection to libvirt host 
          echo "Testing SSH connection to libvirt host..."
          ssh -o ConnectTimeout=10 192.168.0.40 "echo 'SSH connection successful'" || {
            echo "‚ùå SSH connection failed"
            echo "Debug: Testing with verbose output..."
            ssh -vvv 192.168.0.40 "echo 'test'" 2>&1 | tail -20
            exit 1
          }
          
          echo "‚úÖ SSH connection to libvirt host successful"

      - name: 'Test Terraform Cloud Connectivity'
        run: |
          echo "Testing connection to Terraform Cloud..."
          curl -f https://app.terraform.io/api/v2/ping || {
            echo "‚ùå Cannot reach Terraform Cloud"
            exit 1
          }
          echo "‚úÖ Terraform Cloud is reachable"

      - name: 'Emergency Cleanup'
        run: |
          cd ${{ env.WORKING_DIR }}
          echo "üßπ Running emergency cleanup..."
          make clean-ssh || true
          echo "Cleanup completed"
